我其实没有真正意义上用node开发过后台服务，我会对node有了解，比如node其实是用v8引擎，这个时候就会有个问题，那就是内存是不够的，为什么会造成这个原因是因为v8引擎的使用，这个引擎原本是浏览器使用的，低内存是够用的，但是用于开发后台服务时就会限制内存的使用，而node的内存管理机制一般是分为新生内存和老内存，新生内存的定义就是会经常取消和放弃使用，而老内存其实就是会一直存储在内存中，它们两种内存方式使用不一样的垃圾回收机制，新生代使用的是scanvage算法，这个算法会把分配给新生代的内存对半分，并且会在适当的时机，把还在使用的内存从一边复制到另一边，这样子做很快，只需要在每次回收时遍历一半的新生内存即可。而老内存运用的算法其实就是标记清除吧，会吧不需要的内存标记起来并且进行清理，这样子会造成一个问题就是内存碎片化，怎么解决在这个问题呢，就是利用额外的内存整理算法，把老生代的内存整理到一遍空出一大片位置。，然后为什么会运用不同的算法，主要是因为新生的内存变动大，使用scanvage算法1会更合适，因为scanvage算法是以空间换时间而且只关注还存在的算法，而新生代内存变动会更大更适合scanvage算法，而老生代用标记清除法就是因为内存变动少，只需要关注以及没有用的内存即可。同时也有了解node时间处理机制，还有利用node做过一个项目的初始化工具，就是利用node命令去生成项目的必须部分，比如一些config项，可以理解为一个vue-cli项目生成工具。

事件循环机制

其实node中，事件循环机制与浏览器是不一样的，node有一道自己模型，node依靠v8浏览器对js进行解释，解释完后会调用node api，而这些api有libuv引擎驱动，执行对应任务，并把不同的事件加入到不同的队列中等待主线程执行，所以node中的事件循环存在于libuv引擎中。

**事件循环的模型** ：

```
   ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

**事件循环的顺序** ：

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段.

- timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。
- I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
- idle, prepare: 这个阶段仅在内部使用，可以不必理会。
- poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
- check: setImmediate()的回调会在这个阶段执行。
- close callbacks: 例如socket.on('close', ...)这种close事件的回调。

### 1.poll阶段

当v8解析完成之后，循环首先进入poll阶段。poll阶段的执行逻辑如下：

1. 先看poll queue是否有事件，有任务就会按照先进先出的原则

2. 检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。

   同时也会检查是否有到期的timer，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。

   这两者的顺序不固定

3. queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。

### 2.check阶段

check阶段专门用来执行`setImmediate()`方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。

### 3.close阶段

当一个socket连接或者一个handle被突然关闭时（例如调用了`socket.destroy()`方法），close事件会被发送到这个阶段执行回调。否则事件会用`process.nextTick（）`方法发送出去。

### 4.timer阶段

这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。

### 5.I/O callback阶段

这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。

### 6.process.nextTick,setTimeout与setImmediate的区别与使用场景

**process.nextTick**

尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用`process.nextTick()`方法会导致node进入一个死循环。直到内存泄漏。

**setTimeout()**

方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。

**setImmediate()**

方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的`process.nextTick()`方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来---因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。