其实继承在es5中就是对prototype的使用，一般我们会想到的就是构造函数，利用构造函数实现继承

```
function person (a) {
  this.a = a;
}
let man = new person(a);
```

比如我们新构造了一个函数，这个函数的prototype就会自动的生成，我们给这个属性赋值赋予函数，那么在我们new的时候，浏览器就会把prototype属性赋值到新对象的内部属性中（这个属性只能使用_\_proto_\_获取）,而prototype这个属性其实是一个对象，这个对象中含有constructor属性，这个属性会在申明时赋值并且这个属性指向构造函数，所以constructor是不可以信的，一旦我们修改构造函数的prototype的constructor属性为其他值，那么我们new之后，这个值依然会跟随，所以我们可以这么理解，无论我们怎么new，其实就是一个对象的内部属性指向了另一个对象，所以prototype内的属性时可以共享的，一旦我们在某个实例中对\_proto\_操作修改了某个函数，那么我们会出现的一种情况就是，其他的任何关于这个函数的使用都会发生改变，从而可能发生报错，所有我们一定要慎用，而我们知道的js其实都是起源于对象，那么我们其实也可以用object.create  来实现继承，

那么new和Object.create的本质是new关键字创建的对象会保留原构造函数的属性，而用Object.create()创建的对象不会。

也就是其实用new的话，在new的过程中会把构造函数在新环境下执行也就是用call，而Object.create会新创建一个空函数，并且将该函数的prototype赋值给create内的参数在用new进行创建所以他无法保存构造函数的属性

我们在es5中使用的继承方式一般有3中**原型链继承**、**构造函数继承**、**组合继承**

其中原型链继承其实就是把全部的属性都赋值到prototype，这样子做的好处就是，所有的值都是共享的，无法独有，一旦修改多处可用

而构造函数继承，就是使用构造函数，这样子做虽然能让属性值私有化，但是却无法共享，也就是我们无法一处改变多处可用

组合继承就是即使用原型链又使用构造函数这样子做的好处就是，有些属性可以独有无法轻易的呗外界所改变

而在es6中，其实我们说到继承，我们可能更多的想到就是类。其实es6中的类其实就是构造函数的语法糖，类的数据类型是函数，类本身就指向构造函数，事实上类的所有方法都定义在类的prototype属性上，类的内部定义的所有方法都是不可枚举的。而现在我们能实现的是类的静态方法，静态方法我们只需要在方法名前加static即可，而如果需要静态属性，则需要在什么类后，用类型加点加属性名进行赋值。