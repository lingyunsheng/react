# 事件循环机制

## 浏览器环境下的事件循环机制

具体可以参考下如下图

![Image text](https://img-blog.csdn.net/20180524183550464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lMX21heA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 1. 执行栈与事件队列

#### 1.1执行栈

当JS的代码执行的时候会将不同的变量放在内存中的不同位置：堆和栈。其中，堆内存放一些对象，栈内存放基础变量和对象指针。

当我们执行一个方法的时候，js会生成一个与这个方法对应的执行环境，又叫执行上下文。这个执行环境存放着这个方法的私有变量，上层作用域的指向，方法参数，这个作用域中定义的变量以及this对象。当一系列的方法被调用的时候，因为js是单线程，同一时间只能执行一个任务，于是这些方法会被存放在执行栈。

当一个脚本第一次执行的时候，js会解析这段代码，并将其中的同步代码按照执行的顺序加入执行栈中，然后从头开始执行。如果当前执行的是第一个方法，那么js会向执行栈添加这个方法的执行环境，然后在这个环境中继续执行这个代码，如果这个中会调用别的方法，那就就会将调用的方法的执行环境添加进去，然后执行特定的方法，当执行特定的方法完毕，就会退出这个执行环境并销毁回到上一个执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

但是js是非阻塞的，当执行一个异步操作时，就会有另一个东西，**事件队列**

#### 1.2事件队列

js遇到一个异步事件后，会先将这个事件挂起，继续执行执行栈中的其他任务，当一个一步时间返回结果后，并不会马上执行，而是将其加入到时间队列中，等到当前执行栈的所有任务执行完毕，主线程处于空闲状态，主线程才会查看时间队列是否有任务，如果有，就会将第一个任务拿出来放入执行栈（例如回调函数）执行代码。

### 2. macro task与micro task

以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。

以下事件属于宏任务：

- `setInterval()`
- `setTimeout()`

以下事件属于微任务

- `new Promise()`
- `new MutaionObserver()`

前面介绍的一个事件循环中，异步返回的结果被放到一个任务队列中，但是根据异步类型，会分别被放到对应的宏任务或者微任务中，当当前执行栈为空的时候，主线程会查看微任务是否有事件存在，如果不存在，那么再去宏任务里取出一个时间加入到当前执行栈中；如果存在，则会一次取出微任务中的事件，知道微任务队列为空，然后再去执行宏任务中的最前面一个事件。如此反复循环。

如果在浏览器的F12中执行以下这些代码

```javascript
setTimeout(function () {
    console.log(1);
});

new Promise(function(resolve,reject){
    console.log(2)
    resolve(3)
}).then(function(val){
    console.log(val);
})
```

得到的结果为

```
2
3
1
```

## node环境下的事件循环机制

其实node中，事件循环机制与浏览器是不一样的，node有一道自己模型，node依靠v8浏览器对js进行解释，解释完后会调用node api，而这些api有libuv引擎驱动，执行对应任务，并把不同的事件加入到不同的队列中等待主线程执行，所以node中的事件循环存在于libuv引擎中。

**事件循环的模型** ：

```
   ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

**事件循环的顺序** ：

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段.

- timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。
- I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
- idle, prepare: 这个阶段仅在内部使用，可以不必理会。
- poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
- check: setImmediate()的回调会在这个阶段执行。
- close callbacks: 例如socket.on('close', ...)这种close事件的回调。

### 1.poll阶段

当v8解析完成之后，循环首先进入poll阶段。poll阶段的执行逻辑如下：

1. 先看poll queue是否有事件，有任务就会按照先进先出的原则

2. 检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。

   同时也会检查是否有到期的timer，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。

   这两者的顺序不固定

3. queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。

### 2.check阶段

check阶段专门用来执行`setImmediate()`方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。

### 3.close阶段

当一个socket连接或者一个handle被突然关闭时（例如调用了`socket.destroy()`方法），close事件会被发送到这个阶段执行回调。否则事件会用`process.nextTick（）`方法发送出去。

### 4.timer阶段

这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。

### 5.I/O callback阶段

这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。

### 6.process.nextTick,setTimeout与setImmediate的区别与使用场景

**process.nextTick**

尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用`process.nextTick()`方法会导致node进入一个死循环。直到内存泄漏。

**setTimeout()**

方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。

**setImmediate()**

方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的`process.nextTick()`方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来---因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。