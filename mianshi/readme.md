### 301 和 302
- 301 永久性的重定向 永久性转移 从一个旧的网址调到一个新的网址 旧的网址销毁  这个资源不可访问
浏览器在拿到服务器返回的这个状态码 会自动调到一个新的URL地址，这个地址 从location首部获取 a地址变成b
搜索引擎抓取新的内容的同时 将旧的地址交换为重定向之后的地址
- 302 临时性的重定向 暂时性转移 从旧的网址跳到新的网址 旧的网址不变 旧地址a的资源还在 还可以访问 搜索引擎在抓取新的内容的同时 保存旧的网址

- 重定向：
地址a调到地址b 
通过各种方法将各种网络请求重新定个方向转到其他位置
- 为什么要重定向 什么需要重定向
网站调整 网页新地址 网页拓展名改变 否则404 
- 什么时候 进行 301 302 跳转
302 网页网站24-48小时 移动到一个新的位置 302 跳转
301 网站需要移除 需要到新的地址访问

- 尽量使用301跳转
网页劫持 URL劫持
就是一个地址a到地址b 地址a网页差 做了一个 302 重定向 到 地址b网页好 搜索引擎排名靠前 
所以a排名靠前 302 多个域名指向同一个网站 有封站的风险 
301 告诉搜索引擎 地址弃用 转向一个新的地址 可以转移域名的权重
res(301,newUrl)

### 303
请求资源的路径改变 使用GET方法请求新的URL 类似302的功能
url location

### 400 bad request
请求报文存在语法错误 前后端接口数据

提交json json格式问题 400 bad request

### 405 method not allowed
请求方式错误 与后台规定的方式不符合 
get post delete

### 401 用户未提供身份验证凭据 身份验证未通过
### 403 用户身份验证通过 资源访问权限受限
### 404 请求资源不存在 或者 不可用
### 410 请求1资源已转移 不可用
### 415 客户端返回格式不正确
### 422 客户端附件无法处理
### 429 客户端请求次数太多

### 500 客户端请求有效 服务端处理时发生意外 服务端遇到错误 无法完成请求
### 503 服务器无法处理请求 一般用于网站维护 目前无法使用

### 难点 304 307 504 502 501 等等


### 1xx:相关信息
### 2xx: 操作成功
### 3xx: 重定向
### 4xx: 客户端错误
### 5xx: 服务端错误

### 200 成功处理接收到请求 并返回相应网页结果
### 201 生成了新的资源，用户新建数据或者修改数据成功
### 202 服务器收到了请求 但未处理 用于异步操作
### 203 
### 204 从服务器删除资源 资源不存在
### Restful API

### Restful 集中请求格式
- GET 从服务器取出资源  GET/articals/12?categories/12 200 ok
- POST 在服务器新建一个资源 201 created
- PUT 在服务器更新资源 200ok
- PATCH 在服务器部分更新部分资源 200 ok
- DELETE 从服务器删除资源 204 no content 用户删除成功

POST和PUT区别

- POST常用于提交数到服务端 新建资源时使用
- PUT用于修改更新已存在的资源使用
- GET 用于查询数据时使用 不推荐资源的更新以及新建 容易造成xxs或者CSRF攻击

## GET和POST区别
1.url可见性：
get，参数url可见
post，url参数不可见

**get把请求的数据放在url上，即HTTP协议头上，其格式为：以?分割URL和传输数据，参数之间以&相连；post把数据放在HTTP的包体内（requrest body）

2.传输数据的大小：
get一般传输数据大小不超过2k-4k
post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大

**get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url，也没有卵用）；
post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB

3.数据传输上：
get，通过拼接url进行传递参数
post，通过body体传输参数

**GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)

4.后退页面的反应：
get请求页面后退时，不产生影响
post请求页面后退时，会重新提交请求

**GET在浏览器回退时是无影响的，POST会再次提交请求

5.缓存性：
get请求是可以缓存的
post请求不可以缓存

**GET请求会被浏览器主动cache，而POST不会，除非手动设置

6.安全性：
都不安全，原则上post肯定要比get安全，毕竟传输参数时url不可见，但也挡不住部分人闲的没事在那抓包玩，浏览器还会缓存get请求的数据。安全性个人觉得是没多大区别的，防君子不防小人就是这个道理。对传递的参数进行加密，其实都一样

7.GET请求只能进行url编码，而POST支持多种编码方式

8.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留

9.GET只接受ASCII字符的参数的数据类型，而POST没有限制

那么，post那么好为什么还用get？get效率高！

### 数据结构与算法
- 栈 一种先进后出的有序集合 新插入的元素放在栈顶 旧的元素在栈底 新元素靠近栈顶 旧元素靠近栈底
- 队列 遵循先进先出的有序序列 新插入的元素放在队尾 
- 链表 存储有序元素的集合 不同于数组 链表的元素不是有序的 不是连续防止的 是由该元素的结点和指向下一元素的指针或链接组成的
- 集合
- 字典
- 散列表
- 树
- 图

# 栈 一种 先进后出的有序集合
栈是一种遵从先进后出 (LIFO) 原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。
通俗来讲，一摞叠起来的书或盘子都可以看做一个栈，我们想要拿出最底下的书或盘子，一定要现将上面的移走才可以。
1. 定义一个栈 class stack {
    constructor() {
        this.items=[]
    }
}
2. 入栈 this.items.push()
3. 出栈 this.items.push()
4. 栈的末位 peek this.items.length-1
5. 栈是否为空 get isEmpty
6. 栈的大小尺寸 get size
7. 清空栈的内存 clear() {
    this.items=[]
}
8. 输出栈的所有元素 print() {
    console.log(this.items.toString())
}
9. 实例化 new Stack()

# 队列 先进先出的有序序列
与栈相反，队列是一种遵循先进先出 (FIFO / First In First Out) 原则的一组有序的项；队列在尾部添加新元素，并从头部移除元素。最新添加的元素必须排在队列的末尾。
在现实中，最常见的例子就是排队，吃饭排队、银行业务排队、公车的前门上后门下机制...，前面的人优先完成自己的事务，完成之后，下一个人才能继续。
1. 定义一个队列 class queue{
    constructor(items) {
        this.items=items || []
    }
}
2. 入队 this.items.push()
3. 出队 this.items.shift()
4. 队的首位 front this.items[0]
5. 队是否为空 get isEmpty
6. 队的大小尺寸 get size
7. 清空队的内存 clear() {
    this.items=[]
}
8. 输出队的所有元素 print() {
    console.log(this.items.toString())
}
9. 实例化 new Queue()

- 优先队列 循环队列
1. 实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级移除它们。
2. 为充分利用向量空间，克服"假溢出"现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。这种循环队列可以以单链表、队列的方式来在实际编程应用中来实现。





